package jp.gr.java_conf.neko_daisuki.fsyscall.slave;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.zip.DataFormatException;
import java.util.zip.Inflater;

import jp.gr.java_conf.neko_daisuki.fsyscall.Command;
import jp.gr.java_conf.neko_daisuki.fsyscall.CommandDispatcher;
import jp.gr.java_conf.neko_daisuki.fsyscall.DirEntries;
import jp.gr.java_conf.neko_daisuki.fsyscall.Encoder;
import jp.gr.java_conf.neko_daisuki.fsyscall.Errno;
import jp.gr.java_conf.neko_daisuki.fsyscall.KEvent;
import jp.gr.java_conf.neko_daisuki.fsyscall.KEventArray;
import jp.gr.java_conf.neko_daisuki.fsyscall.Logging;
import jp.gr.java_conf.neko_daisuki.fsyscall.PairId;
import jp.gr.java_conf.neko_daisuki.fsyscall.PayloadSize;
import jp.gr.java_conf.neko_daisuki.fsyscall.Pid;
import jp.gr.java_conf.neko_daisuki.fsyscall.PollFd;
import jp.gr.java_conf.neko_daisuki.fsyscall.PollFds;
import jp.gr.java_conf.neko_daisuki.fsyscall.ProtocolError;
import jp.gr.java_conf.neko_daisuki.fsyscall.SigkillException;
import jp.gr.java_conf.neko_daisuki.fsyscall.SignalSet;
import jp.gr.java_conf.neko_daisuki.fsyscall.SocketAddress;
import jp.gr.java_conf.neko_daisuki.fsyscall.SocketOption;
import jp.gr.java_conf.neko_daisuki.fsyscall.SyscallResult;
import jp.gr.java_conf.neko_daisuki.fsyscall.Unix.Constants;
import jp.gr.java_conf.neko_daisuki.fsyscall.Unix;
import jp.gr.java_conf.neko_daisuki.fsyscall.UnixException;
import jp.gr.java_conf.neko_daisuki.fsyscall.UnixDomainAddress;
import jp.gr.java_conf.neko_daisuki.fsyscall.io.SyscallReadableChannel;
import jp.gr.java_conf.neko_daisuki.fsyscall.io.SyscallWritableChannel;
import jp.gr.java_conf.neko_daisuki.fsyscall.util.ArrayUtil;
import jp.gr.java_conf.neko_daisuki.fsyscall.util.ByteUtil;

class SlaveHelper {

    private static class Payload {

        private List<byte[]> mData;

        public Payload() {
            mData = new LinkedList<byte[]>();
        }

        public PayloadSize size() {
            return PayloadSize.fromInteger(computeSize());
        }

        public void add(int n) {
            mData.add(Encoder.encodeInteger(n));
        }

        public void add(long n) {
            mData.add(Encoder.encodeLong(n));
        }

        public void add(Errno e) {
            mData.add(Encoder.encodeInteger(e.toInteger()));
        }

        public void add(Unix.TimeVal tv) {
            add(tv.tv_sec);
            add(tv.tv_usec);
        }

        public void add(Unix.Stat st) {
            add(st.st_dev);
            add(st.st_ino);
            add(st.st_mode);
            add(st.st_nlink);
            add(st.st_uid);
            add(st.st_gid);
            add(st.st_rdev);
            add(st.st_size);
            add(st.st_blocks);
            add(st.st_blksize);
            add(st.st_flags);
            add(st.st_gen);
            add(st.st_lspare);
        }

        public void add(Unix.Rusage rusage) {
            add(rusage.ru_utime);
            add(rusage.ru_stime);
            add(rusage.ru_maxrss);
            add(rusage.ru_ixrss);
            add(rusage.ru_idrss);
            add(rusage.ru_isrss);
            add(rusage.ru_minflt);
            add(rusage.ru_majflt);
            add(rusage.ru_nswap);
            add(rusage.ru_inblock);
            add(rusage.ru_oublock);
            add(rusage.ru_msgsnd);
            add(rusage.ru_msgrcv);
            add(rusage.ru_nsignals);
            add(rusage.ru_nvcsw);
            add(rusage.ru_nivcsw);
        }

        public void add(SocketAddress addr) {
            UnixDomainAddress un = (UnixDomainAddress)addr;
            add(un.getLength());
            add(un.getFamily());
            add(un.getPath());
        }

        public void add(String s) {
            byte[] buffer;
            try {
                buffer = s.getBytes("utf8");
            }
            catch (UnsupportedEncodingException e) {
                throw new Error(e);
            }
            add(buffer.length);
            add(buffer);
        }

        public void add(Unix.Fdset fds) {
            add(fds.size());
            for (Integer fd: fds) {
                add(fd.intValue());
            }
        }

        public void add(byte[] buffer) {
            mData.add(buffer);
        }

        public void add(byte[] buffer, long len) {
            byte[] a = new byte[(int)len];
            for (int i = 0; i < len; i++) {
                a[i] = buffer[i];
            }
            mData.add(a);
        }

        public void add(Pid pid) {
            add(pid.toInteger());
        }

        public byte[] toArray() {
            byte[] data = new byte[computeSize()];
            int pos = 0;
            for (byte[] a: mData) {
                int len = a.length;
                System.arraycopy(a, 0, data, pos, len);
                pos += len;
            }
            return data;
        }

        private int computeSize() {
            int size = 0;
            for (byte[] data: mData) {
                size += data.length;
            }
            return size;
        }
    }

    private static class CommandStatistics {

        private long mNumberOfCalls;
        private long mMaxElapsedTime;       // [usec]
        private long mTotalElapsedTime;     // [usec]

        public void addCall(long elapsedTime) {
            mNumberOfCalls++;
            mMaxElapsedTime = Math.max(mMaxElapsedTime, elapsedTime);
            mTotalElapsedTime += elapsedTime;
        }

        public long getNumberOfCalls() {
            return mNumberOfCalls;
        }

        public long getMaxElapsedTime() {
            return mMaxElapsedTime;
        }

        public long getTotalElapsedTime() {
            return mTotalElapsedTime;
        }
    }

    private static class Statistics {

        private Map<Command, CommandStatistics> mStats;

        public Statistics(Collection<Command> commands) {
            mStats = new HashMap<Command, CommandStatistics>();
            for (Command command: commands) {
                mStats.put(command, new CommandStatistics());
            }
        }

        public CommandStatistics get(Command command) {
            return mStats.get(command);
        }
    }

    @PROCS@

    private class Accept4Proc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            mIn.readPayloadSize();
            int s = mIn.readInteger();
            int addrlen = mIn.readInteger();
            int flags = mIn.readInteger();
            SyscallResult.Accept result = mSlave.doAccept4(s, addrlen, flags);
            writeResult(Command.ACCEPT4_RETURN, result);
        }
    }

    private abstract class AbstractAcceptProc extends CommandDispatcher.Proc {

        private Command mRetCommand;

        public AbstractAcceptProc() {
            mRetCommand = getRetCommand();
        }

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int s = mIn.readInteger();
            int addrlen = mIn.readInteger();
            writeResult(mRetCommand, doSyscall(s, addrlen));
        }

        protected abstract Command getRetCommand();
        protected abstract SyscallResult.Accept doSyscall(int s, int addrlen) throws IOException;
    }

    private class GetpeernameProc extends AbstractAcceptProc {

        protected Command getRetCommand() {
            return Command.GETPEERNAME_RETURN;
        }

        protected SyscallResult.Accept doSyscall(int s, int addrlen) throws IOException {
            return mSlave.doGetpeername(s, addrlen);
        }
    }

    private class GetsocknameProc extends AbstractAcceptProc {

        protected Command getRetCommand() {
            return Command.GETSOCKNAME_RETURN;
        }

        protected SyscallResult.Accept doSyscall(int s, int addrlen) throws IOException {
            return mSlave.doGetsockname(s, addrlen);
        }
    }

    private class AcceptProc extends AbstractAcceptProc {

        protected Command getRetCommand() {
            return Command.ACCEPT_RETURN;
        }

        protected SyscallResult.Accept doSyscall(int s, int addrlen) throws IOException {
            return mSlave.doAccept(s, addrlen);
        }
    }

    private class SigprocmaskProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            SyscallResult.Generic32 result;
            PayloadSize payloadSize = mIn.readPayloadSize();
            int how = mIn.readInteger();
            SignalSet set;
            try {
                set = mIn.readSignalSet();
                result = mSlave.doSigprocmask(how, set);
            }
            catch (UnixException e) {
                mLogger.err(e, "Invalid signal requested");
                result = new SyscallResult.Generic32(e.getErrno());
            }
            writeResult(Command.SIGPROCMASK_RETURN, result);
        }
    }

    private class CloseProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int fd = mIn.readInteger();
            SyscallResult.Generic32 result = mSlave.doClose(fd);
            writeResult(Command.CLOSE_RETURN, result);
        }
    }

    private abstract class SlaveAddingProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            PairId pairId = new PairId(mIn.readInteger());
            SyscallResult.Generic32 result = syscall(pairId);
            writeResult(getReturnCommand(), result);
        }

        protected abstract SyscallResult.Generic32 syscall(PairId newPairId) throws IOException;
        protected abstract Command getReturnCommand();
    }

    private class ForkProc extends SlaveAddingProc {

        protected SyscallResult.Generic32 syscall(PairId newPairId) throws IOException {
            return mSlave.doFork(newPairId);
        }

        protected Command getReturnCommand() {
            return Command.FORK_RETURN;
        }
    }

    private class ThrNewProc extends SlaveAddingProc {

        protected SyscallResult.Generic32 syscall(PairId newPairId) throws IOException {
            return mSlave.doThrNew(newPairId);
        }

        protected Command getReturnCommand() {
            return Command.THR_NEW_RETURN;
        }
    }

    private class SelectProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException, SigkillException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            Unix.Fdset in = readFds();
            Unix.Fdset ou = readFds();
            Unix.Fdset ex = readFds();
            int flag = mIn.readInteger();
            Unix.TimeVal timeout = flag == 0 ? null : mIn.readTimeVal();
            SyscallResult.Select result = mSlave.doSelect(in, ou, ex, timeout);
            writeResult(Command.SELECT_RETURN, result);
        }

        private Unix.Fdset readFds() throws IOException {
            Unix.Fdset fds = new Unix.Fdset();
            int n = mIn.readInteger();
            for (int i = 0; i < n; i++) {
                fds.add(mIn.readInteger());
            }
            return fds;
        }
    }

    private abstract class PollProcBase extends CommandDispatcher.Proc {

        protected class PollArgs {

            public int nfds;
            public PollFds fds;
            public int timeout;

            public PollArgs(int nfds, PollFds fds, int timeout) {
                this.nfds = nfds;
                this.fds = fds;
                this.timeout = timeout;
            }
        }

        protected PollArgs readArgs() throws IOException {
            int nfds = mIn.readInteger();
            PollFds fds = new PollFds();
            for (int i = 0; i < nfds; i++) {
                int fd = mIn.readInteger();
                int events = mIn.readInteger();
                fds.add(new PollFd(fd, events));
            }
            int timeout = mIn.readInteger();

            return new PollArgs(nfds, fds, timeout);
        }

        protected void writeResult(Command command, String name,
                                   SyscallResult.Generic32 result, PollFds fds,
                                   int nfds) throws IOException {
            int retval = result.retval;
            switch (retval) {
            case -1:
            case 0:
                SlaveHelper.this.writeResult(command, result);
                break;
            default:
                String fmt = "result (%s): retval=%d, fds=%s";
                mLogger.info(fmt, name, retval, fds.toString());
                Payload payload = new Payload();
                payload.add(retval);
                for (int i = 0; i < nfds; i++) {
                    payload.add(fds.get(i).getRevents());
                }
                writePayload(command, payload);
                break;
            }
        }
    }

    private class PollStartProc extends PollProcBase {

        public void call(Command command) throws IOException, SigkillException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            PollArgs args = readArgs();
            PollFds fds = args.fds;
            int nfds = args.nfds;
            SyscallResult.Generic32 result = mSlave.doPollStart(fds, nfds,
                                                                args.timeout);
            writeResult(Command.POLL_ENDED, "interruptable poll", result, fds,
                        nfds);
            waitEnd();
        }

        private void waitEnd() throws IOException {
            Command command = mIn.readCommand();
            if (command != Command.POLL_END) {
                String fmt = "expected POLL_END, but actual %s";
                throw new ProtocolError(String.format(fmt, command));
            }
        }
    }

    private class PollProc extends PollProcBase {

        public void call(Command command) throws IOException, SigkillException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            PollArgs args = readArgs();
            int nfds = args.nfds;
            PollFds fds = args.fds;
            int timeout = args.timeout;
            SyscallResult.Generic32 result = mSlave.doPoll(fds, nfds, timeout);
            writeResult(Command.POLL_RETURN, "poll", result, fds, nfds);
        }
    }

    private abstract class AddressCommandProc extends CommandDispatcher.Proc {

        private abstract class FamilyProc {

            public abstract SyscallResult.Generic32 run(int s, int len,
                                                        int family,
                                                        int namelen) throws IOException;
        }

        private class InvalidProc extends FamilyProc {

            public SyscallResult.Generic32 run(int s, int len, int family,
                                               int namelen) throws IOException {
                return new SyscallResult.Generic32(Errno.EINVAL);
            }
        }

        private class UnixDomainProc extends FamilyProc {

            public SyscallResult.Generic32 run(int s, int len, int family,
                                               int namelen) throws IOException {
                String path = mIn.readString();
                UnixDomainAddress name;
                name = new UnixDomainAddress(len, family, path);
                return AddressCommandProc.this.run(s, name, namelen);
            }
        }

        private Command mRetCommand;
        private Map<Integer, FamilyProc> mFamilyProcs;
        private FamilyProc mInvalidProc;

        public AddressCommandProc(Command retCommand) {
            mRetCommand = retCommand;

            mFamilyProcs = new HashMap<Integer, FamilyProc>();
            mFamilyProcs.put(Integer.valueOf(Constants.AF_LOCAL),
                             new UnixDomainProc());
            mInvalidProc = new InvalidProc();
        }

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int s = mIn.readInteger();
            int namelen = mIn.readInteger();
            int len = mIn.readInteger();
            int family = mIn.readInteger();
            FamilyProc proc = getFamilyProc(family);
            SyscallResult.Generic32 retval = proc.run(s, len, family, namelen);
            writeResult(mRetCommand, retval);
        }

        protected abstract SyscallResult.Generic32 run(int s,
                                                       UnixDomainAddress name,
                                                       int namelen) throws IOException;

        private FamilyProc getFamilyProc(int family) {
            FamilyProc proc = mFamilyProcs.get(Integer.valueOf(family));
            return proc != null ? proc : mInvalidProc;
        }
    }

    private class BindProc extends AddressCommandProc {

        public BindProc() {
            super(Command.BIND_RETURN);
        }

        protected SyscallResult.Generic32 run(int s, UnixDomainAddress name,
                                              int namelen) throws IOException {
            return mSlave.doBind(s, name, namelen);
        }
    }

    private class ConnectProc extends AddressCommandProc {

        public ConnectProc() {
            super(Command.CONNECT_RETURN);
        }

        protected SyscallResult.Generic32 run(int s, UnixDomainAddress name,
                                              int namelen) throws IOException {
            return mSlave.doConnect(s, name, namelen);
        }
    }

    private abstract class WritevProcBase extends CommandDispatcher.Proc {

        protected void doWritev(SyscallReadableChannel in) throws IOException {
            int fd = in.readInteger();
            int iovcnt = in.readInteger();
            Unix.IoVec[] iovec = new Unix.IoVec[iovcnt];
            for (int i = 0; i < iovcnt; i++) {
                iovec[i] = in.readIoVec();
            }
            SyscallResult.Generic32 result = mSlave.doWritev(fd, iovec);
            writeResult(Command.WRITEV_RETURN, result);
        }
    }

    private class WritevProc extends WritevProcBase {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            doWritev(mIn);
        }
    }

    private class CompressedWritevCall extends WritevProcBase {

        private class Buffer {

            private byte[] mBuffer = new byte[8192];
            private int mPosition = 0;

            public void put(byte[] source, int length) {
                if (mBuffer.length < mPosition + length) {
                    int n = ((mPosition + length) / 8192 + 1) * 8192;
                    byte[] buffer = new byte[n];
                    System.arraycopy(mBuffer, 0, buffer, 0, mPosition);
                    mBuffer = buffer;
                }

                System.arraycopy(source, 0, mBuffer, mPosition, length);
                mPosition += length;
            }

            public byte[] get() {
                byte[] a = new byte[mPosition];
                System.arraycopy(mBuffer, 0, a, 0, mPosition);
                return a;
            }
        }

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int len = payloadSize.toInteger();
            byte[] compressed = mIn.read(len);

            byte[] decompressed;
            try {
                decompressed = decompress(compressed);
            }
            catch (DataFormatException e) {
                throw new IOException("cannot decompress writev payload", e);
            }
            logMd5("compressed", compressed);
            logMd5("decompressed", decompressed);

            doWritev(new SyscallReadableChannel(decompressed));
        }

        private void logMd5(String tag, byte[] data) throws IOException {
            String algorithm = "MD5";
            MessageDigest md;
            try {
                md = MessageDigest.getInstance(algorithm);
            }
            catch (NoSuchAlgorithmException e) {
                String fmt = "algorithm %s not found";
                throw new IOException(String.format(fmt, algorithm), e);
            }
            md.update(data);
            byte[] digest = md.digest();

            StringBuilder buffer = new StringBuilder();
            int len = digest.length;
            for (int i = 0; i < len; i++) {
                buffer.append(String.format("%02x", digest[i]));
            }

            mLogger.info("%s md5=%s", tag, buffer.toString());
        }

        private byte[] decompress(byte[] compressed)
                                  throws DataFormatException {
            Buffer decompressed = new Buffer();

            Inflater i = new Inflater();
            i.setInput(compressed);
            try {
                byte[] buffer = new byte[8192];
                while (!i.finished()) {
                    int nBytes = i.inflate(buffer);
                    decompressed.put(buffer, nBytes);
                }
            }
            finally {
                String fmt = "inflate: total_in=%d, total_out=%d";
                mLogger.info(fmt, i.getBytesRead(), i.getBytesWritten());
                i.end();
            }

            return decompressed.get();
        }
    }

    private class GetsockoptProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int s = mIn.readInteger();
            int level = mIn.readInteger();
            int optname = mIn.readInteger();
            int optlen = mIn.readInteger();
            SyscallResult.Getsockopt result = mSlave.doGetsockopt(s, level,
                                                                  optname,
                                                                  optlen);
            writeResult(Command.GETSOCKOPT_RETURN, optname, result);
        }
    }

    private class SetsockoptProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int s = mIn.readInteger();
            int level = mIn.readInteger();
            int optname = mIn.readInteger();
            int optlen = mIn.readInteger();
            // TODO: Must switch by optname.
            int optval = mIn.readInteger();
            SyscallResult.Generic32 result = mSlave.doSetsockopt(s, level,
                                                                 optname,
                                                                 optlen,
                                                                 optval);
            writeResult(Command.SETSOCKOPT_RETURN, result);
        }
    }

    private class KeventProc extends CommandDispatcher.Proc {

        private static final int KEVENT_CHANGELIST_NULL = 0;
        private static final int KEVENT_CHANGELIST_NOT_NULL = 1;
        private static final int KEVENT_TIMEOUT_NULL = 0;
        private static final int KEVENT_TIMEOUT_NOT_NULL = 1;
        private static final int KEVENT_UDATA_NULL = 0;
        private static final int KEVENT_UDATA_NOT_NULL = 1;

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int kq = mIn.readInteger();
            int nchanges = mIn.readInteger();
            KEventArray changelist;
            int changelist_code = mIn.readInteger();
            switch (changelist_code) {
            case KEVENT_CHANGELIST_NOT_NULL:
                changelist = new KEventArray(nchanges);
                for (int i = 0; i < nchanges; i++) {
                    KEvent kev = changelist.get(i);
                    kev.ident = mIn.readInteger();
                    kev.filter = mIn.readShort();
                    kev.flags = mIn.readInteger();
                    kev.fflags = mIn.readInteger();
                    kev.data = mIn.readInteger();
                    int udata_code = mIn.readInteger();
                    if (udata_code != KEVENT_UDATA_NULL) {
                        String fmt = "unsupported udata code: %d";
                        throw new ProtocolError(String.format(fmt, udata_code));
                    }
                }
                break;
            case KEVENT_CHANGELIST_NULL:
                changelist = null;
                break;
            default:
                String fmt = "invalid changelist code: %d";
                throw new ProtocolError(String.format(fmt, changelist_code));
            }
            int nevents = mIn.readInteger();
            Unix.TimeSpec timeout;
            int timeout_code = mIn.readInteger();
            switch (timeout_code) {
            case KEVENT_TIMEOUT_NOT_NULL:
                timeout = new Unix.TimeSpec();
                timeout.tv_sec = mIn.readInteger();
                timeout.tv_nsec = mIn.readInteger();
                break;
            case KEVENT_TIMEOUT_NULL:
                timeout = null;
                break;
            default:
                String fmt = "invalid timeout code: %d";
                throw new ProtocolError(String.format(fmt, timeout_code));
            }

            SyscallResult.Kevent retval = mSlave.doKevent(kq, changelist,
                                                          nchanges, nevents,
                                                          timeout);

            writeResult(Command.KEVENT_RETURN, retval);
        }
    }

    private abstract class MsgProc extends CommandDispatcher.Proc {

        protected static final int MSGHDR_MSG_NAME_NULL = 0;
        protected static final int MSGHDR_MSG_NAME_NOT_NULL = 1;
        protected static final int MSGHDR_MSG_CONTROL_NULL = 0;
        protected static final int MSGHDR_MSG_CONTROL_NOT_NULL = 1;

        public abstract void call(Command command) throws IOException;
    }

    private class RecvmsgProc extends MsgProc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();

            int fd = mIn.readInteger();

            int namecode = mIn.readInteger();
            switch (namecode) {
            case MSGHDR_MSG_NAME_NOT_NULL:
                // TODO: return EOPNOTSUPP.
                throw new IOException();
            case MSGHDR_MSG_NAME_NULL:
                break;
            default:
                // TODO: return EINVAL.
                throw new IOException();
            }

            int iovlen = mIn.readInteger();
            Unix.IoVec[] iov = new Unix.IoVec[iovlen];
            for (int i = 0; i < iovlen; i++) {
                int len = mIn.readInteger();
                // the buffer in iovec is unused.
                iov[i] = new Unix.IoVec(null, len);
            }

            int controllen = mIn.readInteger();
            Unix.Cmsghdr[] control = 0 < controllen ? new Unix.Cmsghdr[1]
                                                    : null;
            Unix.Msghdr msg = new Unix.Msghdr(iov, control, mIn.readInteger());

            int flags = mIn.readInteger();

            SyscallResult.Recvmsg result = mSlave.doRecvmsg(fd, msg, flags);

            writeResult(Command.RECVMSG_RETURN, result);
        }
    }

    private class SendmsgProc extends MsgProc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();

            int fd = mIn.readInteger();

            int namecode = mIn.readInteger();
            switch (namecode) {
            case MSGHDR_MSG_NAME_NOT_NULL:
                // TODO: return EOPNOTSUPP.
                throw new IOException();
            case MSGHDR_MSG_NAME_NULL:
                break;
            default:
                // TODO: return EINVAL.
                throw new IOException();
            }

            int iovlen = mIn.readInteger();
            Unix.IoVec[] iov = new Unix.IoVec[iovlen];
            for (int i = 0; i < iovlen; i++) {
                int len = mIn.readInteger();
                byte[] buf = mIn.read(len);
                iov[i] = new Unix.IoVec(buf, len);
            }

            Unix.Cmsghdr[] cmsghdrs = readControlHeaders();
            Unix.Msghdr msg = new Unix.Msghdr(iov, cmsghdrs, mIn.readInteger());

            int flags = mIn.readInteger();

            SyscallResult.Generic64 result = mSlave.doSendmsg(fd, msg, flags);

            writeResult(Command.SENDMSG_RETURN, result);
        }

        private Unix.Cmsghdr[] buildControlHeaders() throws IOException {
            int ncmsghdrs = mIn.readInteger();
            Unix.Cmsghdr[] cmsghdrs = new Unix.Cmsghdr[ncmsghdrs];

            for (int i = 0; i < ncmsghdrs; i++) {
                int level = mIn.readInteger();
                int type = mIn.readInteger();
                Unix.Cmsgdata data;
                switch (level) {
                case Unix.Constants.SOL_SOCKET:
                    switch (type) {
                    case Unix.Constants.SCM_CREDS:
                        data = null;
                        break;
                    case Unix.Constants.SCM_RIGHTS:
                        int nfds = mIn.readInteger();
                        data = new Unix.Cmsgfds(nfds);
                        break;
                    default:
                        // TODO: throw better exception
                        throw new IOException();
                    }
                    break;
                default:
                    // TODO: throw better exception.
                    throw new IOException();
                }

                cmsghdrs[i] = new Unix.Cmsghdr(level, type, data);
            }

            return cmsghdrs;
        }

        private void readControlBody(Unix.Cmsghdr[] cmsghdrs) throws IOException {
            int ncmsghdrs = cmsghdrs.length;
            for (int i = 0; i < ncmsghdrs; i++) {
                Unix.Cmsghdr cmsghdr = cmsghdrs[i];
                switch (cmsghdr.cmsg_level) {
                case Unix.Constants.SOL_SOCKET:
                    switch (cmsghdr.cmsg_type) {
                    case Unix.Constants.SCM_CREDS:
                        // nothing
                        break;
                    case Unix.Constants.SCM_RIGHTS:
                        Unix.Cmsgfds cmsgfds = (Unix.Cmsgfds)cmsghdr.cmsg_data;
                        int[] fds = cmsgfds.fds;
                        int nfds = fds.length;
                        for (int j = 0; j < nfds; j++) {
                            fds[j] = mIn.readInteger();
                        }
                        break;
                    default:
                        break;
                    }
                    break;
                default:
                    break;
                }
            }
        }

        private Unix.Cmsghdr[] readControlHeaders() throws IOException {
            Unix.Cmsghdr[] cmsghdrs;
            int controlcode = mIn.readInteger();
            switch (controlcode) {
            case MSGHDR_MSG_CONTROL_NOT_NULL:
                cmsghdrs = buildControlHeaders();
                readControlBody(cmsghdrs);
                break;
            case MSGHDR_MSG_CONTROL_NULL:
                cmsghdrs = null;
                break;
            default:
                // TODO: return EINVAL.
                throw new IOException();
            }

            return cmsghdrs;
        }
    }

    private class GetdirentriesProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int fd = mIn.readInteger();
            int nMax = mIn.readInteger();

            SyscallResult.Getdirentries result = mSlave.doGetdirentries(fd,
                                                                        nMax);

            writeResult(Command.GETDIRENTRIES_RETURN, result);
        }
    }

    private class OpenatProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            mIn.readPayloadSize();  // unused

            int fd = mIn.readInteger();
            String path = mIn.readString();
            int flags = mIn.readInteger();
            int mode = (flags & Unix.Constants.O_CREAT) != 0 ? mIn.readInteger()
                                                             : 0;

            SyscallResult.Generic32 result = mSlave.doOpenat(fd, path, flags,
                                                             mode);

            writeResult(Command.OPENAT_RETURN, result);
        }
    }

    private class FcntlProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            mIn.readPayloadSize();  // unused

            int fd = mIn.readInteger();
            int cmd = mIn.readInteger();
            long arg;
            switch (cmd) {
            case Unix.Constants.F_GETFD:
            case Unix.Constants.F_GETFL:
                arg = 0;    // unused, to make the compiler quiet.
                break;
            case Unix.Constants.F_SETFD:
            case Unix.Constants.F_SETFL:
            default:
                arg = mIn.readLong();
                break;
            }

            SyscallResult.Generic32 result = mSlave.doFcntl(fd, cmd, arg);

            writeResult(Command.FCNTL_RETURN, result);
        }
    }

    private class UtimesProc extends CommandDispatcher.Proc {

        private static final short UTIMES_TIMES_NULL = 0;
        private static final short UTIMES_TIMES_NOT_NULL = 1;

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            String path = mIn.readString();
            Unix.TimeVal[] times;
            short timesCode = mIn.readShort();
            switch (timesCode) {
            case UTIMES_TIMES_NOT_NULL:
                times = new Unix.TimeVal[2];
                for (int i = 0; i < times.length; i++) {
                    times[i] = mIn.readTimeVal();
                }
                break;
            case UTIMES_TIMES_NULL:
                times = null;
                break;
            default:
                String fmt = "unsupported times code to utimes(2): %d";
                throw new ProtocolError(String.format(fmt, timesCode));
            }

            SyscallResult.Generic32 result = mSlave.doUtimes(path, times);

            writeResult(Command.UTIMES_RETURN, result);
        }
    }

    private class ThrExitProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            mSlave.doThrExit();
        }
    }

    private class ExitProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            mSlave.doExit(mIn.readInteger());
        }
    }

    private static Logging.Logger mLogger;

    private Slave mSlave;
    private SyscallReadableChannel mIn;
    private SyscallWritableChannel mOut;

    private CommandDispatcher mDispatcher;
    private Statistics mStatistics;

    public SlaveHelper(Slave slave, SyscallReadableChannel in,
                       SyscallWritableChannel out) {
        mSlave = slave;
        mIn = in;
        mOut = out;

        mDispatcher = buildDispatcher();
        mStatistics = new Statistics(mDispatcher.commandSet());
    }

    public void runSlave() throws IOException, SigkillException {
        Command command = mIn.readCommand();
        mLogger.debug("read command: %s", command.toString());

        CommandDispatcher.Proc proc = mDispatcher.get(command);
        if (proc == null) {
            String fmt = "cannot handle command of %s";
            throw new ProtocolError(String.format(fmt, command.toString()));
        }

        long t0 = System.nanoTime();

        proc.call(command);

        long t1 = System.nanoTime();
        mStatistics.get(command).addCall((t1 - t0) / 1000);
    }

    public void printStatistics() {
        String numericFormat = "%,d";
        String fmt = String.format("statistics: command=%%s, number of calls=%1$s, total elapsed time=%1$s[usec], max elapsed time=%1$s[usec], average elapsed time=%%s[usec]", numericFormat);

        Command[] ca = mDispatcher.commandSet().toArray(new Command[0]);
        Arrays.sort(ca, Command.COMPARATOR);
        for (Command command: ca) {
            CommandStatistics stat = mStatistics.get(command);
            long nCalls = stat.getNumberOfCalls();
            long totalElapsedTime = stat.getTotalElapsedTime();
            mLogger.info(fmt,
                         command, nCalls, totalElapsedTime,
                         stat.getMaxElapsedTime(),
                         nCalls != 0 ? String.format(numericFormat,
                                                     totalElapsedTime / nCalls)
                                     : "-");
        }
    }

    private CommandDispatcher buildDispatcher() {
        CommandDispatcher dispatcher = new CommandDispatcher();
        dispatcher.addEntry(Command.EXIT_CALL, new ExitProc());
        dispatcher.addEntry(Command.CLOSE_CALL, new CloseProc());
        dispatcher.addEntry(Command.SELECT_CALL, new SelectProc());
        dispatcher.addEntry(Command.CONNECT_CALL, new ConnectProc());
        dispatcher.addEntry(Command.BIND_CALL, new BindProc());
        dispatcher.addEntry(Command.POLL_CALL, new PollProc());
        dispatcher.addEntry(Command.FORK_CALL, new ForkProc());
        dispatcher.addEntry(Command.ACCEPT_CALL, new AcceptProc());
        dispatcher.addEntry(Command.GETSOCKNAME_CALL, new GetsocknameProc());
        dispatcher.addEntry(Command.GETPEERNAME_CALL, new GetpeernameProc());
        dispatcher.addEntry(Command.GETSOCKOPT_CALL, new GetsockoptProc());
        dispatcher.addEntry(Command.SETSOCKOPT_CALL, new SetsockoptProc());
        dispatcher.addEntry(Command.KEVENT_CALL, new KeventProc());
        dispatcher.addEntry(Command.SIGPROCMASK_CALL, new SigprocmaskProc());
        dispatcher.addEntry(Command.POLL_START, new PollStartProc());
        dispatcher.addEntry(Command.SENDMSG_CALL, new SendmsgProc());
        dispatcher.addEntry(Command.RECVMSG_CALL, new RecvmsgProc());
        dispatcher.addEntry(Command.THR_NEW_CALL, new ThrNewProc());
        dispatcher.addEntry(Command.THR_EXIT_CALL, new ThrExitProc());
        dispatcher.addEntry(Command.UTIMES_CALL, new UtimesProc());
        dispatcher.addEntry(Command.GETDIRENTRIES_CALL,
                            new GetdirentriesProc());
        dispatcher.addEntry(Command.FCNTL_CALL, new FcntlProc());
        dispatcher.addEntry(Command.OPENAT_CALL, new OpenatProc());
        dispatcher.addEntry(Command.ACCEPT4_CALL, new Accept4Proc());
        dispatcher.addEntry(Command.COMPRESSED_WRITEV_CALL,
                            new CompressedWritevCall());
        @DISPATCHES@;
        return dispatcher;
    }

    private void writePayload(Command command, Payload payload) throws IOException {
        mOut.write(command);
        mOut.write(payload.size());
        mOut.write(payload.toArray());
    }

    private void writeError(Command command, int retval, Errno errno) throws IOException {
        Payload payload = new Payload();
        payload.add(retval);
        payload.add(errno);

        writePayload(command, payload);
    }

    private void writeError(Command command, SyscallResult.Generic32 result) throws IOException {
        writeError(command, result.retval, result.errno);
    }

    private void writeError(Command command, SyscallResult.Generic64 result) throws IOException {
        Payload payload = new Payload();
        payload.add(result.retval);
        payload.add(result.errno);

        writePayload(command, payload);
    }

    private int countCmsghdrs(Unix.Cmsghdr[] control) {
        int n = 0;
        int len = control.length;
        for (int i = 0; (i < len) && (control[i] != null); i++) {
            n++;
        }
        return n;
    }

    private void writeResult(Command command,
                             SyscallResult.Recvmsg result) throws IOException {
        String logHead = "result (recvmsg)";

        long retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(fmt, logHead, retval, result.errno);
            writeError(command, result);
            return;
        }

        mLogger.info("%s: retval=%d, buf=%s, control=%s",
                     logHead, retval,
                     ByteUtil.toString(result.buf, (int)retval),
                     ArrayUtil.toString(result.control));

        Payload payload = new Payload();
        payload.add(result.retval);
        payload.add(result.buf, result.retval);

        Unix.Cmsghdr[] control = result.control;
        if (control != null) {
            int ncmsghdrs = countCmsghdrs(control);
            payload.add(ncmsghdrs);
            for (int i = 0; i < ncmsghdrs; i++) {
                Unix.Cmsghdr cmsghdr = control[i];
                int level = cmsghdr.cmsg_level;
                int type = cmsghdr.cmsg_type;
                payload.add(level);
                payload.add(type);
                switch (level) {
                case Unix.Constants.SOL_SOCKET:
                    switch (type) {
                    case Unix.Constants.SCM_CREDS:
                        // nothing.
                        break;
                    case Unix.Constants.SCM_RIGHTS:
                        Unix.Cmsgfds data = (Unix.Cmsgfds)cmsghdr.cmsg_data;
                        payload.add(data.fds.length);
                        break;
                    default:
                        break;
                    }
                    break;
                default:
                    break;
                }
            }

            for (int i = 0; i < ncmsghdrs; i++) {
                Unix.Cmsghdr cmsghdr = control[i];
                switch (cmsghdr.cmsg_level) {
                case Unix.Constants.SOL_SOCKET:
                    switch (cmsghdr.cmsg_type) {
                    case Unix.Constants.SCM_CREDS:
                        Unix.Cmsgcred cred = (Unix.Cmsgcred)cmsghdr.cmsg_data;
                        payload.add(cred.cmcred_pid);
                        payload.add(cred.cmcred_uid);
                        payload.add(cred.cmcred_euid);
                        payload.add(cred.cmcred_gid);
                        int[] groups = cred.cmcred_groups;
                        int ngroups = groups.length;
                        payload.add(ngroups);
                        for (int j = 0; j < ngroups; j++) {
                            payload.add(groups[j]);
                        }
                        break;
                    case Unix.Constants.SCM_RIGHTS:
                        Unix.Cmsgfds data = (Unix.Cmsgfds)cmsghdr.cmsg_data;
                        int[] fds = data.fds;
                        int nfds = fds.length;
                        for (int j = 0; j < nfds; j++) {
                            payload.add(fds[j]);
                        }
                        break;
                    default:
                        break;
                    }
                    break;
                default:
                    break;
                }
            }
        }

        writePayload(command, payload);
    }

    private void writeResult(Command command, int optname,
                             SyscallResult.Getsockopt result)
                             throws IOException {
        String logHead = "result (getsockopt)";

        long retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(fmt, logHead, retval, result.errno);
            writeError(command, result);
            return;
        }

        SocketOption option = SocketOption.valueOf(optname);
        if (option.equals(SocketOption.SO_REUSEADDR)) {
            String fmt = "%s: retval=%d, optval=%d, optlen=%d";
            mLogger.info(fmt, logHead, result.retval, result.n, result.optlen);

            Payload payload = new Payload();
            payload.add(result.retval);
            payload.add(result.optlen);
            payload.add(result.n);

            writePayload(command, payload);
        }
    }

    private void writeResult(Command command, SyscallResult.Generic64 result) throws IOException {
        String logHead = "result (generic64)";

        long retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(fmt, logHead, retval, result.errno);

            writeError(command, result);
            return;
        }

        mLogger.info("%s: retval=%d", logHead, retval);

        Payload payload = new Payload();
        payload.add(retval);

        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Generic32 result) throws IOException {
        String logHead = "result (generic32)";

        int retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(fmt, logHead, retval, result.errno);

            writeError(command, result);
            return;
        }

        mLogger.info("%s: retval=%d", logHead, retval);

        Payload payload = new Payload();
        payload.add(retval);

        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Wait4 result) throws IOException {
        String logHead = "result (wait4)";

        int retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(fmt, logHead, retval, result.errno);
            writeError(command, result);
            return;
        }

        String fmt = "%s: retval=%d, status=%d, rusage=%s";
        int status = result.status;
        Unix.Rusage rusage = result.rusage;
        mLogger.info(fmt, logHead, retval, status, rusage);

        Payload payload = new Payload();
        payload.add(retval);
        payload.add(status);
        payload.add(rusage);
        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Gettimeofday result) throws IOException {
        String logHead = "result (gettimeofday)";

        int retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(fmt, logHead, retval, result.errno);
            writeError(command, result);
            return;
        }

        String fmt = "%s: retval=%d, tp->tv_sec=%d, tp->tv_usec=%d, tzp->tz_minuteswest=%d, tzp->tz_dsttime=%d";
        mLogger.info(fmt,
                     logHead, retval, result.tp.tv_sec, result.tp.tv_usec,
                     result.tzp.tz_minuteswest, result.tzp.tz_dsttime);

        Payload payload = new Payload();
        payload.add(retval);
        payload.add(result.tp.tv_sec);
        payload.add(result.tp.tv_usec);
        payload.add(result.tzp.tz_minuteswest);
        payload.add(result.tzp.tz_dsttime);
        writePayload(command, payload);
    }

    private void writeResult(Command command, String name, int retval,
                             Errno errno, long rxid, long exid, long sxid) throws IOException {
        String logHead = String.format("result (%s)", name);

        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(fmt, logHead, retval, errno);
            writeError(command, retval, errno);
            return;
        }

        mLogger.info("%s: retval=%d", logHead, retval);

        Payload payload = new Payload();
        payload.add(retval);
        payload.add(rxid);
        payload.add(exid);
        payload.add(sxid);
        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Getresgid result) throws IOException {
        writeResult(command, "getresgid", result.retval, result.errno,
                    result.rgid, result.egid, result.sgid);
    }

    private void writeResult(Command command, SyscallResult.Getresuid result) throws IOException {
        writeResult(command, "getresuid", result.retval, result.errno,
                    result.ruid, result.euid, result.suid);
    }

    private void writeResult(Command command, SyscallResult.Kevent result) throws IOException {
        String logHead = "result (kevent)";

        long retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(fmt, logHead, retval, result.errno);
            writeError(command, result);
            return;
        }

        // TODO
        throw new IOException();
    }

    private void writeResult(Command command, SyscallResult.Accept result) throws IOException {
        String logHead = "result (accept)";

        long retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(fmt, logHead, retval, result.errno);
            writeError(command, result);
            return;
        }

        String fmt = "%s: retval=%d, addr=%s, addrlen=%d";
        SocketAddress addr = result.addr;
        mLogger.info(fmt, logHead, retval, addr, result.addrlen);

        Payload payload = new Payload();
        payload.add(retval);
        payload.add(result.addrlen);
        payload.add(addr);

        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Getdirentries result) throws IOException {
        String logHead = "result (getdirentries)";

        int retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(fmt, logHead, retval, result.errno);
            writeError(command, result);
            return;
        }

        DirEntries entries = result.dirEntries;
        mLogger.info("%s: retval=%d, entries=%s", logHead, retval, entries);

        Payload payload = new Payload();
        payload.add(retval);
        payload.add(entries.size());
        for (Unix.DirEnt entry: entries) {
            payload.add(entry.d_fileno);
            payload.add(entry.d_type);
            payload.add(entry.d_name);
        }
        payload.add(entries.getBase());

        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Select result) throws IOException {
        String logHead = "result (select)";

        int retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(fmt, logHead, retval, result.errno);

            writeError(command, result);
            return;
        }

        mLogger.info("%s: retval=%d", logHead, retval);

        Payload payload = new Payload();
        payload.add(retval);
        if (0 < retval) {
            payload.add(result.in);
            payload.add(result.ou);
            payload.add(result.ex);
        }

        writePayload(command, payload);
    }

    @WRITE_RESULT@

    static {
        mLogger = new Logging.Logger("SlaveHelper");
    }
}

/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=java
 */
