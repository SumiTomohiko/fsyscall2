package jp.gr.java_conf.neko_daisuki.fsyscall.slave;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import jp.gr.java_conf.neko_daisuki.fsyscall.Command;
import jp.gr.java_conf.neko_daisuki.fsyscall.CommandDispatcher;
import jp.gr.java_conf.neko_daisuki.fsyscall.Encoder;
import jp.gr.java_conf.neko_daisuki.fsyscall.Errno;
import jp.gr.java_conf.neko_daisuki.fsyscall.Logging;
import jp.gr.java_conf.neko_daisuki.fsyscall.PairId;
import jp.gr.java_conf.neko_daisuki.fsyscall.PayloadSize;
import jp.gr.java_conf.neko_daisuki.fsyscall.Pid;
import jp.gr.java_conf.neko_daisuki.fsyscall.PollFd;
import jp.gr.java_conf.neko_daisuki.fsyscall.PollFds;
import jp.gr.java_conf.neko_daisuki.fsyscall.ProtocolError;
import jp.gr.java_conf.neko_daisuki.fsyscall.Sigaction;
import jp.gr.java_conf.neko_daisuki.fsyscall.SocketAddress;
import jp.gr.java_conf.neko_daisuki.fsyscall.SyscallResult;
import jp.gr.java_conf.neko_daisuki.fsyscall.Unix.Constants;
import jp.gr.java_conf.neko_daisuki.fsyscall.Unix;
import jp.gr.java_conf.neko_daisuki.fsyscall.UnixException;
import jp.gr.java_conf.neko_daisuki.fsyscall.UnixDomainAddress;
import jp.gr.java_conf.neko_daisuki.fsyscall.io.SyscallInputStream;
import jp.gr.java_conf.neko_daisuki.fsyscall.io.SyscallOutputStream;

class SlaveHelper {

    private static class Payload {

        private List<byte[]> mData;

        public Payload() {
            mData = new LinkedList<byte[]>();
        }

        public PayloadSize size() {
            return PayloadSize.fromInteger(computeSize());
        }

        public void add(int n) {
            mData.add(Encoder.encodeInteger(n));
        }

        public void add(long n) {
            mData.add(Encoder.encodeLong(n));
        }

        public void add(Errno e) {
            mData.add(Encoder.encodeInteger(e.toInteger()));
        }

        public void add(Unix.TimeVal tv) {
            add(tv.tv_sec);
            add(tv.tv_usec);
        }

        public void add(Unix.Stat st) {
            add(st.st_dev);
            add(st.st_ino);
            add(st.st_mode);
            add(st.st_nlink);
            add(st.st_uid);
            add(st.st_gid);
            add(st.st_rdev);
            add(st.st_size);
            add(st.st_blocks);
            add(st.st_blksize);
            add(st.st_flags);
            add(st.st_gen);
            add(st.st_lspare);
        }

        public void add(Unix.Rusage rusage) {
            add(rusage.ru_utime);
            add(rusage.ru_stime);
            add(rusage.ru_maxrss);
            add(rusage.ru_ixrss);
            add(rusage.ru_idrss);
            add(rusage.ru_isrss);
            add(rusage.ru_minflt);
            add(rusage.ru_majflt);
            add(rusage.ru_nswap);
            add(rusage.ru_inblock);
            add(rusage.ru_oublock);
            add(rusage.ru_msgsnd);
            add(rusage.ru_msgrcv);
            add(rusage.ru_nsignals);
            add(rusage.ru_nvcsw);
            add(rusage.ru_nivcsw);
        }

        public void add(SocketAddress addr) {
            UnixDomainAddress un = (UnixDomainAddress)addr;
            add(un.getLength());
            add(un.getFamily());
            add(un.getPath());
        }

        public void add(String s) {
            byte[] buffer;
            try {
                buffer = s.getBytes("utf8");
            }
            catch (UnsupportedEncodingException e) {
                throw new Error(e);
            }
            add(buffer.length);
            add(buffer);
        }

        public void add(Collection<Integer> fds) {
            add(fds.size());
            for (Integer fd: fds) {
                add(fd.intValue());
            }
        }

        public void add(byte[] buffer) {
            mData.add(buffer);
        }

        public byte[] toArray() {
            byte[] data = new byte[computeSize()];
            int pos = 0;
            for (byte[] a: mData) {
                int len = a.length;
                System.arraycopy(a, 0, data, pos, len);
                pos += len;
            }
            return data;
        }

        private int computeSize() {
            int size = 0;
            for (byte[] data: mData) {
                size += data.length;
            }
            return size;
        }
    }

    @PROCS@

    private abstract class AbstractAcceptProc extends CommandDispatcher.Proc {

        private Command mRetCommand;

        public AbstractAcceptProc() {
            mRetCommand = getRetCommand();
        }

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int s = mIn.readInteger();
            int addrlen = mIn.readInteger();
            writeResult(mRetCommand, doSyscall(s, addrlen));
        }

        protected abstract Command getRetCommand();
        protected abstract SyscallResult.Accept doSyscall(int s, int addrlen) throws IOException;
    }

    private class GetpeernameProc extends AbstractAcceptProc {

        protected Command getRetCommand() {
            return Command.RET_GETPEERNAME;
        }

        protected SyscallResult.Accept doSyscall(int s, int addrlen) throws IOException {
            return mSlave.doGetpeername(s, addrlen);
        }
    }

    private class GetsocknameProc extends AbstractAcceptProc {

        protected Command getRetCommand() {
            return Command.RET_GETSOCKNAME;
        }

        protected SyscallResult.Accept doSyscall(int s, int addrlen) throws IOException {
            return mSlave.doGetsockname(s, addrlen);
        }
    }

    private class AcceptProc extends AbstractAcceptProc {

        protected Command getRetCommand() {
            return Command.RET_ACCEPT;
        }

        protected SyscallResult.Accept doSyscall(int s, int addrlen) throws IOException {
            return mSlave.doAccept(s, addrlen);
        }
    }

    private class SigactionProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int sig = mIn.readInteger();
            SyscallResult.Generic32 result;
             try {
                Sigaction act = mIn.readSigaction();
                result = mSlave.doSigaction(sig, act);
             }
             catch (UnixException e) {
                mLogger.err("Invalid signal requested", e);
                result = new SyscallResult.Generic32(e.getErrno());
             }
            writeResult(Command.RET_SIGACTION, result);
        }
    }

    private class ForkProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            PairId pairId = new PairId(mIn.readInteger());
            SyscallResult.Generic32 result = mSlave.doFork(pairId);
            writeResult(Command.RET_FORK, result);
        }
    }

    private class SelectProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int nfds = mIn.readInteger();
            Collection<Integer> in = readFds();
            Collection<Integer> ou = readFds();
            Collection<Integer> ex = readFds();
            int flag = mIn.readInteger();
            Unix.TimeVal timeout = flag == 0 ? null : readTimeVal();
            SyscallResult.Select result = mSlave.doSelect(nfds, in, ou, ex, timeout);
            writeResult(Command.RET_SELECT, result);
        }

        private Unix.TimeVal readTimeVal() throws IOException {
            Unix.TimeVal tv = new Unix.TimeVal();
            tv.tv_sec = mIn.readLong();
            tv.tv_usec = mIn.readLong();
            return tv;
        }

        private Collection<Integer> readFds() throws IOException {
            Collection<Integer> fds = new HashSet<Integer>();
            int n = mIn.readInteger();
            for (int i = 0; i < n; i++) {
                fds.add(Integer.valueOf(mIn.readInteger()));
            }
            return fds;
        }
    }

    private class PollProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int nfds = mIn.readInteger();
            PollFds fds = new PollFds();
            for (int i = 0; i < nfds; i++) {
                int fd = mIn.readInteger();
                int events = mIn.readInteger();
                fds.add(new PollFd(fd, events));
            }
            int timeout = mIn.readInteger();
            SyscallResult.Generic32 result = mSlave.doPoll(fds, nfds, timeout);
            int retval = result.retval;
            switch (retval) {
            case -1:
            case 0:
                writeResult(Command.RET_POLL, result);
                break;
            default:
                String fmt = "result (poll): retval=%d, fds=%s";
                mLogger.info(String.format(fmt, retval, fds.toString()));
                Payload payload = new Payload();
                payload.add(retval);
                for (int i = 0; i < nfds; i++) {
                    payload.add(fds.get(i).getRevents());
                }
                writePayload(Command.RET_POLL, payload);
                break;
            }
        }
    }

    private abstract class AddressCommandProc extends CommandDispatcher.Proc {

        private abstract class FamilyProc {

            public abstract SyscallResult.Generic32 run(int s, int len,
                                                        int family,
                                                        int namelen) throws IOException;
        }

        private class InvalidProc extends FamilyProc {

            public SyscallResult.Generic32 run(int s, int len, int family,
                                               int namelen) throws IOException {
                return new SyscallResult.Generic32(Errno.EINVAL);
            }
        }

        private class UnixDomainProc extends FamilyProc {

            public SyscallResult.Generic32 run(int s, int len, int family,
                                               int namelen) throws IOException {
                String path = mIn.readString();
                UnixDomainAddress name;
                name = new UnixDomainAddress(len, family, path);
                return AddressCommandProc.this.run(s, name, namelen);
            }
        }

        private Command mRetCommand;
        private Map<Integer, FamilyProc> mFamilyProcs;
        private FamilyProc mInvalidProc;

        public AddressCommandProc(Command retCommand) {
            mRetCommand = retCommand;

            mFamilyProcs = new HashMap<Integer, FamilyProc>();
            mFamilyProcs.put(Integer.valueOf(Constants.AF_LOCAL),
                             new UnixDomainProc());
            mInvalidProc = new InvalidProc();
        }

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int s = mIn.readInteger();
            int namelen = mIn.readInteger();
            int len = mIn.readInteger();
            int family = mIn.readInteger();
            FamilyProc proc = getFamilyProc(family);
            SyscallResult.Generic32 retval = proc.run(s, len, family, namelen);
            writeResult(mRetCommand, retval);
        }

        protected abstract SyscallResult.Generic32 run(int s,
                                                       UnixDomainAddress name,
                                                       int namelen) throws IOException;

        private FamilyProc getFamilyProc(int family) {
            FamilyProc proc = mFamilyProcs.get(Integer.valueOf(family));
            return proc != null ? proc : mInvalidProc;
        }
    }

    private class BindProc extends AddressCommandProc {

        public BindProc() {
            super(Command.RET_BIND);
        }

        protected SyscallResult.Generic32 run(int s, UnixDomainAddress name,
                                              int namelen) throws IOException {
            return mSlave.doBind(s, name, namelen);
        }
    }

    private class ConnectProc extends AddressCommandProc {

        public ConnectProc() {
            super(Command.RET_CONNECT);
        }

        protected SyscallResult.Generic32 run(int s, UnixDomainAddress name,
                                              int namelen) throws IOException {
            return mSlave.doConnect(s, name, namelen);
        }
    }

    private class WritevProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int fd = mIn.readInteger();
            int iovcnt = mIn.readInteger();
            Unix.IoVec[] iovec = new Unix.IoVec[iovcnt];
            for (int i = 0; i < iovcnt; i++) {
                iovec[i] = mIn.readIoVec();
            }
            SyscallResult.Generic32 result = mSlave.doWritev(fd, iovec);
            writeResult(Command.RET_WRITEV, result);
        }
    }

    private class ExitProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            mSlave.doExit(mIn.readInteger());
        }
    }

    private static Logging.Logger mLogger;

    private Slave mSlave;
    private SyscallInputStream mIn;
    private SyscallOutputStream mOut;

    private CommandDispatcher mDispatcher;

    public SlaveHelper(Slave slave, SyscallInputStream in, SyscallOutputStream out) {
        mSlave = slave;
        mIn = in;
        mOut = out;

        mDispatcher = buildDispatcher();
    }

    public void runSlave() throws IOException {
        Command command = mIn.readCommand();
        mLogger.debug(String.format("read command: %s", command.toString()));

        CommandDispatcher.Proc proc = mDispatcher.get(command);
        if (proc == null) {
            String fmt = "cannot handle command of %s";
            throw new ProtocolError(String.format(fmt, command.toString()));
        }

        proc.call(command);
    }

    private CommandDispatcher buildDispatcher() {
        CommandDispatcher dispatcher = new CommandDispatcher();
        dispatcher.addEntry(Command.CALL_EXIT, new ExitProc());
        dispatcher.addEntry(Command.CALL_SELECT, new SelectProc());
        dispatcher.addEntry(Command.CALL_CONNECT, new ConnectProc());
        dispatcher.addEntry(Command.CALL_BIND, new BindProc());
        dispatcher.addEntry(Command.CALL_POLL, new PollProc());
        dispatcher.addEntry(Command.CALL_FORK, new ForkProc());
        dispatcher.addEntry(Command.CALL_SIGACTION, new SigactionProc());
        dispatcher.addEntry(Command.CALL_ACCEPT, new AcceptProc());
        dispatcher.addEntry(Command.CALL_GETSOCKNAME, new GetsocknameProc());
        dispatcher.addEntry(Command.CALL_GETPEERNAME, new GetpeernameProc());
        @DISPATCHES@;
        return dispatcher;
    }

    private void writePayload(Command command, Payload payload) throws IOException {
        mOut.write(command);
        mOut.write(payload.size());
        mOut.write(payload.toArray());
    }

    private void writeError(Command command, SyscallResult.Generic32 result) throws IOException {
        Payload payload = new Payload();
        payload.add(result.retval);
        payload.add(result.errno);

        writePayload(command, payload);
    }

    private void writeError(Command command, SyscallResult.Generic64 result) throws IOException {
        Payload payload = new Payload();
        payload.add(result.retval);
        payload.add(result.errno);

        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Generic64 result) throws IOException {
        String logHead = "result (generic64)";

        long retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(String.format(fmt, logHead, retval, result.errno));

            writeError(command, result);
            return;
        }

        mLogger.info(String.format("%s: retval=%d", logHead, retval));

        Payload payload = new Payload();
        payload.add(retval);

        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Generic32 result) throws IOException {
        String logHead = "result (generic32)";

        int retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(String.format(fmt, logHead, retval, result.errno));

            writeError(command, result);
            return;
        }

        mLogger.info(String.format("%s: retval=%d", logHead, retval));

        Payload payload = new Payload();
        payload.add(retval);

        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Wait4 result) throws IOException {
        String logHead = "result (wait4)";

        int retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(String.format(fmt, logHead, retval, result.errno));
            writeError(command, result);
            return;
        }

        String fmt = "%s: retval=%d, status=%d, rusage=%s";
        int status = result.status;
        Unix.Rusage rusage = result.rusage;
        mLogger.info(String.format(fmt, logHead, retval, status, rusage));

        Payload payload = new Payload();
        payload.add(retval);
        payload.add(status);
        payload.add(rusage);
        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Gettimeofday result) throws IOException {
        String logHead = "result (gettimeofday)";

        int retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(String.format(fmt, logHead, retval, result.errno));
            writeError(command, result);
            return;
        }

        String fmt = "%s: retval=%d, tp->tv_sec=%d, tp->tv_usec=%d, tzp->tz_minuteswest=%d, tzp->tz_dsttime=%d";
        mLogger.info(String.format(fmt, logHead, retval, result.tp.tv_sec,
                                   result.tp.tv_usec, result.tzp.tz_minuteswest,
                                   result.tzp.tz_dsttime));

        Payload payload = new Payload();
        payload.add(retval);
        payload.add(result.tp.tv_sec);
        payload.add(result.tp.tv_usec);
        payload.add(result.tzp.tz_minuteswest);
        payload.add(result.tzp.tz_dsttime);
        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Getresuid result) throws IOException {
        String logHead = "result (getresuid)";

        int retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(String.format(fmt, logHead, retval, result.errno));
            writeError(command, result);
            return;
        }

        mLogger.info(String.format("%s: retval=%d", logHead, retval));

        Payload payload = new Payload();
        payload.add(retval);
        payload.add(result.ruid);
        payload.add(result.euid);
        payload.add(result.suid);
        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Accept result) throws IOException {
        String logHead = "result (accept)";

        long retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(String.format(fmt, logHead, retval, result.errno));
            writeError(command, result);
            return;
        }

        String fmt = "%s: retval=%d, addr=%s, addrlen=%d";
        SocketAddress addr = result.addr;
        mLogger.info(String.format(fmt, logHead, retval, addr, result.addrlen));

        Payload payload = new Payload();
        payload.add(retval);
        payload.add(result.addrlen);
        payload.add(addr);

        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Select result) throws IOException {
        String logHead = "result (select)";

        int retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(String.format(fmt, logHead, retval, result.errno));

            writeError(command, result);
            return;
        }

        mLogger.info(String.format("%s: retval=%d", logHead, retval));

        Payload payload = new Payload();
        payload.add(retval);
        if (0 < retval) {
            payload.add(result.in);
            payload.add(result.ou);
            payload.add(result.ex);
        }

        writePayload(command, payload);
    }

    @WRITE_RESULT@

    static {
        mLogger = new Logging.Logger("SlaveHelper");
    }
}

/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=java
 */
