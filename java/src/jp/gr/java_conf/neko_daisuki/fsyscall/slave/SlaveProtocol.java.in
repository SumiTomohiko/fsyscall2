package jp.gr.java_conf.neko_daisuki.fsyscall.slave;

import java.io.IOException;

import jp.gr.java_conf.neko_daisuki.fsyscall.Command;
import jp.gr.java_conf.neko_daisuki.fsyscall.CommandDispatcher;
import jp.gr.java_conf.neko_daisuki.fsyscall.L;
import jp.gr.java_conf.neko_daisuki.fsyscall.ProtocolError;
import jp.gr.java_conf.neko_daisuki.fsyscall.SyscallResult;
import jp.gr.java_conf.neko_daisuki.fsyscall.io.SyscallInputStream;
import jp.gr.java_conf.neko_daisuki.fsyscall.io.SyscallOutputStream;

@IMPORTS@;

public class SlaveProtocol {

    /* Example.
    private class OpenProc extends CommandDispatcher.Proc {

        public void call(Command _) {
            OpenArgs args = new OpenArgs();
            args.path = mIn.readString();
            SyscallResult result = mSlave.doOpen(args);
            // TODO: Return to master.
        }
    }
    */

    @PROCS@

    private Slave mSlave;
    private SyscallInputStream mIn;
    private SyscallOutputStream mOut;
    private CommandDispatcher mDispatcher;

    public SlaveProtocol(Slave slave, SyscallInputStream in, SyscallOutputStream out) {
        mSlave = slave;
        mIn = in;
        mOut = out;
        mDispatcher = buildDispatcher();
    }

    public void communicate() throws IOException {
        Command command = mIn.readCommand();
        L.info(String.format("read command: %s", command.toString()));

        CommandDispatcher.Proc proc = mDispatcher.get(command);
        if (proc == null) {
            String fmt = "cannot handle command of %s";
            throw new ProtocolError(String.format(fmt, command.toString()));
        }
        proc.call(command);
    }

    private CommandDispatcher buildDispatcher() {
        CommandDispatcher dispatcher = new CommandDispatcher();
        @DISPATCHES@;
        return dispatcher;
    }
}

/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=java
 */
