package jp.gr.java_conf.neko_daisuki.fsyscall.slave;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import jp.gr.java_conf.neko_daisuki.fsyscall.Encoder;
import jp.gr.java_conf.neko_daisuki.fsyscall.L;
import jp.gr.java_conf.neko_daisuki.fsyscall.Pid;
import jp.gr.java_conf.neko_daisuki.fsyscall.SyscallResult;
import jp.gr.java_conf.neko_daisuki.fsyscall.io.SyscallInputStream;
import jp.gr.java_conf.neko_daisuki.fsyscall.io.SyscallOutputStream;

@IMPORTS@;

public class Slave extends Worker {

    private static class UnixFile {

        public InputStream in;
        public OutputStream out;
    }

    private static final int UNIX_FILE_NUM = 256;

    private Application mApplication;
    private SyscallInputStream mIn;
    private SyscallOutputStream mOut;
    private SlaveProtocol mProtocol;

    private UnixFile[] mFiles;

    // Cache
    private SyscallResult mResult;

    public Slave(Application application, InputStream in, OutputStream out) throws IOException {
        L.info("a slave is starting.");

        mApplication = application;
        mIn = new SyscallInputStream(in);
        mOut = new SyscallOutputStream(out);
        mProtocol = new SlaveProtocol(this, mIn, mOut);

        mFiles = new UnixFile[UNIX_FILE_NUM];

        mResult = new SyscallResult();

        writeOpenedFileDescriptors();
        L.info("file descripters were transfered from the slave.");
    }

    public boolean isReady() throws IOException {
        return mIn.isReady();
    }

    public void work() throws IOException {
        mProtocol.communicate();
    }

    public SyscallResult doOpen(OpenArgs args) throws IOException {
        SyscallResult result = getSyscallResult();
        result.n = 0;
        result.errno = 0;
        return result;
    }

    public SyscallResult doRead(ReadArgs args) throws IOException {
        return null;
    }

    public SyscallResult doLseek(LseekArgs args) throws IOException {
        return null;
    }

    public SyscallResult doMmap(MmapArgs args) throws IOException {
        return null;
    }

    public SyscallResult doPread(PreadArgs args) throws IOException {
        return null;
    }

    public SyscallResult doIssetugid(IssetugidArgs args) throws IOException {
        return null;
    }

    public SyscallResult doLstat(LstatArgs args) throws IOException {
        return null;
    }

    public SyscallResult doFstat(FstatArgs args) throws IOException {
        return null;
    }

    public SyscallResult doStat(StatArgs args) throws IOException {
        return null;
    }

    public SyscallResult doWritev(WritevArgs args) throws IOException {
        return null;
    }

    public SyscallResult doSelect(SelectArgs args) throws IOException {
        return null;
    }

    public SyscallResult doReadlink(ReadlinkArgs args) throws IOException {
        return null;
    }

    public SyscallResult doIoctl(IoctlArgs args) throws IOException {
        return null;
    }

    public SyscallResult doAccess(AccessArgs args) throws IOException {
        return null;
    }

    public SyscallResult doLink(LinkArgs args) throws IOException {
        return null;
    }

    public SyscallResult doClose(CloseArgs args) throws IOException {
        return null;
    }

    public SyscallResult doWrite(WriteArgs args) throws IOException {
        return null;
    }

    public SyscallResult doExit(ExitArgs args) throws IOException {
        mIn.close();
        mOut.close();
        mApplication.removeSlave(this);
        mApplication.setExitStatus(args.rval);
        return null;
    }

    private SyscallResult getSyscallResult() {
        return mResult;
    }

    private void writeOpenedFileDescriptors() throws IOException {
        int fds[] = { 0, 1, 2 };
        byte[][] buffers = new byte[fds.length][];
        for (int i = 0; i < fds.length; i++) {
            buffers[i] = Encoder.encodeInteger(fds[i]);
        }
        int len = 0;
        for (int i = 0; i < fds.length; i++) {
            len += buffers[i].length;
        }

        mOut.writeInteger(len);
        for (int i = 0; i < fds.length; i++) {
            mOut.write(buffers[i]);
        }
    }
}

/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=java
 */
