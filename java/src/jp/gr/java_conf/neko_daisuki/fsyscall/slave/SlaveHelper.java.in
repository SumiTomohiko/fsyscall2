package jp.gr.java_conf.neko_daisuki.fsyscall.slave;

import java.io.IOException;

import jp.gr.java_conf.neko_daisuki.fsyscall.Command;
import jp.gr.java_conf.neko_daisuki.fsyscall.CommandDispatcher;
import jp.gr.java_conf.neko_daisuki.fsyscall.Encoder;
import jp.gr.java_conf.neko_daisuki.fsyscall.L;
import jp.gr.java_conf.neko_daisuki.fsyscall.PayloadSize;
import jp.gr.java_conf.neko_daisuki.fsyscall.ProtocolError;
import jp.gr.java_conf.neko_daisuki.fsyscall.SyscallResult;
import jp.gr.java_conf.neko_daisuki.fsyscall.Unix.FdSet;
import jp.gr.java_conf.neko_daisuki.fsyscall.Unix.Stat;
import jp.gr.java_conf.neko_daisuki.fsyscall.Unix.TimeVal;
import jp.gr.java_conf.neko_daisuki.fsyscall.io.SyscallInputStream;
import jp.gr.java_conf.neko_daisuki.fsyscall.io.SyscallOutputStream;

public class SlaveHelper {

    private static class Logger {

        public static void info(String message) {
            L.info(buildMessage(message));
        }

        private static String buildMessage(String message) {
            return String.format("SlaveHelper: %s", message);
        }
    }

    @PROCS@

    private class ExitProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            mSlave.doExit(mIn.readInteger());
        }
    }

    private Slave mSlave;
    private SyscallInputStream mIn;
    private SyscallOutputStream mOut;

    private CommandDispatcher mDispatcher;

    public SlaveHelper(Slave slave, SyscallInputStream in, SyscallOutputStream out) {
        mSlave = slave;
        mIn = in;
        mOut = out;

        mDispatcher = buildDispatcher();
    }

    public void runSlave() throws IOException {
        Command command = mIn.readCommand();
        Logger.info(String.format("read command: %s", command.toString()));

        CommandDispatcher.Proc proc = mDispatcher.get(command);
        if (proc == null) {
            String fmt = "cannot handle command of %s";
            throw new ProtocolError(String.format(fmt, command.toString()));
        }

        proc.call(command);
    }

    private CommandDispatcher buildDispatcher() {
        CommandDispatcher dispatcher = new CommandDispatcher();
        @DISPATCHES@;
        return dispatcher;
    }

    private void writeResult(Command command, SyscallResult.Generic64 result) throws IOException {
        byte[] returnedValue = Encoder.encodeLong(result.retval);
        byte[] errno = result.retval != -1 ? new byte[0] : Encoder.encodeInteger(result.errno.toInteger());

        writeResult(command, returnedValue, errno);
    }

    private void writeResult(Command command, SyscallResult.Generic32 result) throws IOException {
        byte[] returnedValue = Encoder.encodeInteger(result.retval);
        byte[] errno = result.retval != -1 ? new byte[0] : Encoder.encodeInteger(result.errno.toInteger());

        writeResult(command, returnedValue, errno);
    }

    private void writeResult(Command command, byte[] returnedValue, byte[] errno) throws IOException {
        int len = returnedValue.length + errno.length;
        PayloadSize payloadSize = PayloadSize.fromInteger(len);

        mOut.write(command);
        mOut.write(payloadSize);
        mOut.write(returnedValue);
        mOut.write(errno);
    }
}

/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=java
 */
