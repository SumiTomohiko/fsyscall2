package jp.gr.java_conf.neko_daisuki.fsyscall.slave;

import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import jp.gr.java_conf.neko_daisuki.fsyscall.Command;
import jp.gr.java_conf.neko_daisuki.fsyscall.CommandDispatcher;
import jp.gr.java_conf.neko_daisuki.fsyscall.Encoder;
import jp.gr.java_conf.neko_daisuki.fsyscall.Errno;
import jp.gr.java_conf.neko_daisuki.fsyscall.Logging;
import jp.gr.java_conf.neko_daisuki.fsyscall.PayloadSize;
import jp.gr.java_conf.neko_daisuki.fsyscall.Pid;
import jp.gr.java_conf.neko_daisuki.fsyscall.PollFd;
import jp.gr.java_conf.neko_daisuki.fsyscall.PollFds;
import jp.gr.java_conf.neko_daisuki.fsyscall.ProtocolError;
import jp.gr.java_conf.neko_daisuki.fsyscall.SyscallResult;
import jp.gr.java_conf.neko_daisuki.fsyscall.Unix.Constants;
import jp.gr.java_conf.neko_daisuki.fsyscall.Unix;
import jp.gr.java_conf.neko_daisuki.fsyscall.UnixDomainAddress;
import jp.gr.java_conf.neko_daisuki.fsyscall.io.SyscallInputStream;
import jp.gr.java_conf.neko_daisuki.fsyscall.io.SyscallOutputStream;

public class SlaveHelper {

    private static class Payload {

        private List<byte[]> mData;

        public Payload() {
            mData = new LinkedList<byte[]>();
        }

        public PayloadSize size() {
            return PayloadSize.fromInteger(computeSize());
        }

        public void add(int n) {
            mData.add(Encoder.encodeInteger(n));
        }

        public void add(long n) {
            mData.add(Encoder.encodeLong(n));
        }

        public void add(Errno e) {
            mData.add(Encoder.encodeInteger(e.toInteger()));
        }

        public void add(Unix.Stat st) {
            add(st.st_dev);
            add(st.st_ino);
            add(st.st_mode);
            add(st.st_nlink);
            add(st.st_uid);
            add(st.st_gid);
            add(st.st_rdev);
            add(st.st_size);
            add(st.st_blocks);
            add(st.st_blksize);
            add(st.st_flags);
            add(st.st_gen);
            add(st.st_lspare);
        }

        public void add(Collection<Integer> fds) {
            add(fds.size());
            for (Integer fd: fds) {
                add(fd.intValue());
            }
        }

        public void add(byte[] buffer) {
            mData.add(buffer);
        }

        public byte[] toArray() {
            byte[] data = new byte[computeSize()];
            int pos = 0;
            for (byte[] a: mData) {
                int len = a.length;
                System.arraycopy(a, 0, data, pos, len);
                pos += len;
            }
            return data;
        }

        private int computeSize() {
            int size = 0;
            for (byte[] data: mData) {
                size += data.length;
            }
            return size;
        }
    }

    @PROCS@

    private class ForkProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            Pid pid = new Pid(mIn.readInteger());
            SyscallResult.Generic32 result = mSlave.doFork(pid);
            writeResult(Command.RET_FORK, result);
        }
    }

    private class SelectProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int nfds = mIn.readInteger();
            Collection<Integer> in = readFds();
            Collection<Integer> ou = readFds();
            Collection<Integer> ex = readFds();
            int flag = mIn.readInteger();
            Unix.TimeVal timeout = flag == 0 ? null : readTimeVal();
            SyscallResult.Select result = mSlave.doSelect(nfds, in, ou, ex, timeout);
            writeResult(Command.RET_SELECT, result);
        }

        private Unix.TimeVal readTimeVal() throws IOException {
            Unix.TimeVal tv = new Unix.TimeVal();
            tv.tv_sec = mIn.readLong();
            tv.tv_usec = mIn.readLong();
            return tv;
        }

        private Collection<Integer> readFds() throws IOException {
            Collection<Integer> fds = new HashSet<Integer>();
            int n = mIn.readInteger();
            for (int i = 0; i < n; i++) {
                fds.add(Integer.valueOf(mIn.readInteger()));
            }
            return fds;
        }
    }

    private class PollProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int nfds = mIn.readInteger();
            PollFds fds = new PollFds();
            for (int i = 0; i < nfds; i++) {
                int fd = mIn.readInteger();
                int events = mIn.readInteger();
                fds.add(new PollFd(fd, events));
            }
            int timeout = mIn.readInteger();
            SyscallResult.Generic32 result = mSlave.doPoll(fds, nfds, timeout);
            int retval = result.retval;
            switch (retval) {
            case -1:
            case 0:
                writeResult(Command.RET_POLL, result);
                break;
            default:
                String fmt = "result (poll): retval=%d, fds=%s";
                mLogger.info(String.format(fmt, retval, fds.toString()));
                Payload payload = new Payload();
                payload.add(retval);
                for (int i = 0; i < nfds; i++) {
                    payload.add(fds.get(i).getRevents());
                }
                writePayload(Command.RET_POLL, payload);
                break;
            }
        }
    }

    private class ConnectProc extends CommandDispatcher.Proc {

        private abstract class FamilyProc {

            public abstract SyscallResult.Generic32 run(int s, int len,
                                                        int family,
                                                        int namelen) throws IOException;
        }

        private class InvalidProc extends FamilyProc {

            public SyscallResult.Generic32 run(int s, int len, int family,
                                               int namelen) throws IOException {
                SyscallResult.Generic32 result;
                result = new SyscallResult.Generic32();
                result.retval = -1;
                result.errno = Errno.EINVAL;
                return result;
            }
        }

        private class UnixDomainProc extends FamilyProc {

            public SyscallResult.Generic32 run(int s, int len, int family,
                                               int namelen) throws IOException {
                String path = mIn.readString();
                UnixDomainAddress name;
                name = new UnixDomainAddress(len, family, path);
                return mSlave.doConnect(s, name, namelen);
            }
        }

        private FamilyProc mInvalidProc;
        private Map<Integer, FamilyProc> mFamilyProcs;

        public ConnectProc() {
            mFamilyProcs = new HashMap<Integer, FamilyProc>();
            mFamilyProcs.put(Integer.valueOf(Constants.AF_LOCAL),
                             new UnixDomainProc());
            mInvalidProc = new InvalidProc();
        }

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int s = mIn.readInteger();
            int namelen = mIn.readInteger();
            int len = mIn.readInteger();
            int family = mIn.readInteger();
            FamilyProc proc = getFamilyProc(family);
            SyscallResult.Generic32 retval = proc.run(s, len, family, namelen);
            writeResult(Command.RET_CONNECT, retval);
        }

        private FamilyProc getFamilyProc(int family) {
            FamilyProc proc = mFamilyProcs.get(Integer.valueOf(family));
            return proc != null ? proc : mInvalidProc;
        }
    }

    private class WritevProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            PayloadSize payloadSize = mIn.readPayloadSize();
            int fd = mIn.readInteger();
            int iovcnt = mIn.readInteger();
            Unix.IoVec[] iovec = new Unix.IoVec[iovcnt];
            for (int i = 0; i < iovcnt; i++) {
                iovec[i] = mIn.readIoVec();
            }
            SyscallResult.Generic32 result = mSlave.doWritev(fd, iovec);
            writeResult(Command.RET_WRITEV, result);
        }
    }

    private class ExitProc extends CommandDispatcher.Proc {

        public void call(Command command) throws IOException {
            mSlave.doExit(mIn.readInteger());
        }
    }

    private static Logging.Logger mLogger;

    private Slave mSlave;
    private SyscallInputStream mIn;
    private SyscallOutputStream mOut;

    private CommandDispatcher mDispatcher;

    public SlaveHelper(Slave slave, SyscallInputStream in, SyscallOutputStream out) {
        mSlave = slave;
        mIn = in;
        mOut = out;

        mDispatcher = buildDispatcher();
    }

    public void runSlave() throws IOException {
        Command command = mIn.readCommand();
        mLogger.debug(String.format("read command: %s", command.toString()));

        CommandDispatcher.Proc proc = mDispatcher.get(command);
        if (proc == null) {
            String fmt = "cannot handle command of %s";
            throw new ProtocolError(String.format(fmt, command.toString()));
        }

        proc.call(command);
    }

    private CommandDispatcher buildDispatcher() {
        CommandDispatcher dispatcher = new CommandDispatcher();
        dispatcher.addEntry(Command.CALL_EXIT, new ExitProc());
        dispatcher.addEntry(Command.CALL_SELECT, new SelectProc());
        dispatcher.addEntry(Command.CALL_CONNECT, new ConnectProc());
        dispatcher.addEntry(Command.CALL_POLL, new PollProc());
        dispatcher.addEntry(Command.CALL_FORK, new ForkProc());
        @DISPATCHES@;
        return dispatcher;
    }

    private void writePayload(Command command, Payload payload) throws IOException {
        mOut.write(command);
        mOut.write(payload.size());
        mOut.write(payload.toArray());
    }

    private void writeError(Command command, SyscallResult.Generic32 result) throws IOException {
        Payload payload = new Payload();
        payload.add(result.retval);
        payload.add(result.errno);

        writePayload(command, payload);
    }

    private void writeError(Command command, SyscallResult.Generic64 result) throws IOException {
        Payload payload = new Payload();
        payload.add(result.retval);
        payload.add(result.errno);

        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Generic64 result) throws IOException {
        String logHead = "result (generic64)";

        long retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(String.format(fmt, logHead, retval, result.errno));

            writeError(command, result);
            return;
        }

        mLogger.info(String.format("%s: retval=%d", logHead, retval));

        Payload payload = new Payload();
        payload.add(retval);

        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Generic32 result) throws IOException {
        String logHead = "result (generic32)";

        int retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(String.format(fmt, logHead, retval, result.errno));

            writeError(command, result);
            return;
        }

        mLogger.info(String.format("%s: retval=%d", logHead, retval));

        Payload payload = new Payload();
        payload.add(retval);

        writePayload(command, payload);
    }

    private void writeResult(Command command, SyscallResult.Select result) throws IOException {
        String logHead = "result (select)";

        int retval = result.retval;
        if (retval == -1) {
            String fmt = "%s: retval=%d, errno=%s";
            mLogger.info(String.format(fmt, logHead, retval, result.errno));

            writeError(command, result);
            return;
        }

        mLogger.info(String.format("%s: retval=%d", logHead, retval));

        Payload payload = new Payload();
        payload.add(retval);
        if (0 < retval) {
            payload.add(result.in);
            payload.add(result.ou);
            payload.add(result.ex);
        }

        writePayload(command, payload);
    }

    @WRITE_RESULT@

    static {
        mLogger = new Logging.Logger("SlaveHelper");
    }
}

/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=java
 */
